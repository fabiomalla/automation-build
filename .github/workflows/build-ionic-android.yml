run-name: Build Ionic Android - ${{ github.event.inputs.client_name || 'all' }}

on:
  workflow_dispatch:
    inputs:
      client_name:
        description: "Nome del cliente da buildare (es: napoli, sibook-tattoo)"
        required: true
        type: string
      branch:
        description: "Branch del repository privato da buildare (opzionale: per 'sibook' usa automaticamente 'shop/sibook', per altri clienti usa 'main')"
        required: false
        default: ""
        type: string
      build_only:
        description: "Solo build senza upload (default: false)"
        required: false
        default: false
        type: boolean
      deploy_vps:
        description: "Deploy su VPS dopo build (default: true)"
        required: false
        default: true
        type: boolean
      setup_nginx:
        description: "Configura Nginx sulla VPS (crea config, URL, etc.) (default: false)"
        required: false
        default: false
        type: boolean
  repository_dispatch:
    types: [build-ionic-android]

env:
  NODE_VERSION: '22.21.1'
  JAVA_VERSION: '21'

jobs:
  build_android:
    runs-on: ubuntu-latest

    steps:

      - name: Determine client name
        id: client
        run: |
          if [ -n "${{ github.event.inputs.client_name }}" ]; then
            CLIENT_NAME="${{ github.event.inputs.client_name }}"
          elif [ -n "${{ github.event.client_payload.client_name }}" ]; then
            CLIENT_NAME="${{ github.event.client_payload.client_name }}"
          else
            CLIENT_NAME="all"
          fi
          echo "client_name=$CLIENT_NAME" >> $GITHUB_OUTPUT
          echo "üîç Client da buildare: $CLIENT_NAME"

      - name: Determine branch based on client
        id: branch_determine
        run: |
          # Se il branch √® stato specificato esplicitamente, usalo
          if [ -n "${{ github.event.inputs.branch }}" ]; then
            BRANCH="${{ github.event.inputs.branch }}"
            echo "üîÄ Branch specificato manualmente: $BRANCH"
          elif [ -n "${{ github.event.client_payload.branch }}" ]; then
            BRANCH="${{ github.event.client_payload.branch }}"
            echo "üîÄ Branch da payload: $BRANCH"
          else
            # Determina il branch in base al cliente
            CLIENT_NAME="${{ steps.client.outputs.client_name }}"
            
            if [ "$CLIENT_NAME" == "sibook" ]; then
              BRANCH="shop/sibook"
              echo "üîÄ Cliente 'sibook' rilevato ‚Üí usando branch: $BRANCH"
            else
              BRANCH="main"
              echo "üîÄ Cliente '$CLIENT_NAME' ‚Üí usando branch default: $BRANCH"
            fi
          fi
          
          echo "branch=$BRANCH" >> $GITHUB_OUTPUT
          echo "‚úÖ Branch determinato: $BRANCH"

      - name: Checkout the Private Repository
        uses: actions/checkout@v3
        with:
          repository: lorenzomalla/sibook-app-ionic
          token: ${{ secrets.EASYBOOK_RELEASE_AUTOMATION_REPO_TOKEN }}
          ref: ${{ steps.branch_determine.outputs.branch }}

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Setup Java
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: ${{ env.JAVA_VERSION }}

      - name: Install dependencies
        run: |
          # Rimuovi package-lock.json e node_modules per evitare bug npm con dipendenze opzionali
          rm -rf node_modules package-lock.json
          npm install

      - name: Get clients list
        id: clients
        run: |
          if [ "${{ steps.client.outputs.client_name }}" == "all" ]; then
            CLIENTS=$(node -e "const fs = require('fs'); const config = JSON.parse(fs.readFileSync('./clients.config.json', 'utf8')); console.log(Object.keys(config.clients).join(','))")
            echo "clients=$CLIENTS" >> $GITHUB_OUTPUT
            echo "üì¶ Clienti trovati: $CLIENTS"
          else
            echo "clients=${{ steps.client.outputs.client_name }}" >> $GITHUB_OUTPUT
          fi

      - name: Detect release account from clients.config.json
        id: release_account
        run: |
          # Leggi releaseAccount dal clients.config.json
          # Se ci sono pi√π clienti, verifica che abbiano tutti lo stesso account
          CLIENTS="${{ steps.clients.outputs.clients }}"
          IFS=',' read -ra CLIENTS_ARRAY <<< "$CLIENTS"
          
          RELEASE_ACCOUNTS=()
          for CLIENT in "${CLIENTS_ARRAY[@]}"; do
            ACCOUNT=$(node -e "const fs = require('fs'); const config = JSON.parse(fs.readFileSync('./clients.config.json', 'utf8')); console.log(config.clients?.['$CLIENT']?.releaseAccount || 'lorenzo')")
            RELEASE_ACCOUNTS+=("$ACCOUNT")
            echo "üìã Client '$CLIENT' ‚Üí releaseAccount: $ACCOUNT"
          done
          
          # Verifica che tutti i clienti abbiano lo stesso account
          UNIQUE_ACCOUNTS=($(printf '%s\n' "${RELEASE_ACCOUNTS[@]}" | sort -u))
          if [ ${#UNIQUE_ACCOUNTS[@]} -gt 1 ]; then
            echo "‚ùå Errore: I clienti hanno account di rilascio diversi!"
            echo "   Account trovati: ${UNIQUE_ACCOUNTS[*]}"
            echo "   Non √® possibile buildare clienti con account diversi nella stessa esecuzione."
            exit 1
          fi
          
          # Usa l'account del primo cliente (tutti sono uguali)
          RELEASE_ACCOUNT="${RELEASE_ACCOUNTS[0]}"
          echo "release_account=$RELEASE_ACCOUNT" >> $GITHUB_OUTPUT
          echo "‚úÖ Account di rilascio determinato: $RELEASE_ACCOUNT"

      # Sceglie le credenziali Play Store in base a releaseAccount
      - name: Set environment variables for Android
        run: |
          RELEASE_ACCOUNT="${{ steps.release_account.outputs.release_account }}"
          
          if [ "$RELEASE_ACCOUNT" = "sibook" ]; then
            # Controllo di sicurezza: se manca il secret fallisce subito
            if [ -z "${{ secrets.GOOGLE_PLAY_JSON_KEY_BASE64_SIBOOK }}" ]; then
              echo "‚ùå Missing GOOGLE_PLAY_JSON_KEY_BASE64_SIBOOK while SIBOOK_RELEASE=true"
              exit 1
            fi

            echo "üîµ Using SiBook Google Play account"
            echo "GOOGLE_PLAY_EMAIL=${{ secrets.GOOGLE_PLAY_EMAIL_SIBOOK }}" >> $GITHUB_ENV
            echo "GOOGLE_PLAY_PASSWORD=${{ secrets.GOOGLE_PLAY_PASSWORD_SIBOOK }}" >> $GITHUB_ENV
            echo "GOOGLE_PLAY_JSON_KEY_BASE64=${{ secrets.GOOGLE_PLAY_JSON_KEY_BASE64_SIBOOK }}" >> $GITHUB_ENV
          else
            echo "üü¢ Using Lorenzo Google Play account (default)"
            if [ -z "${{ secrets.GOOGLE_PLAY_JSON_KEY_BASE64 }}" ]; then
              echo "‚ùå Missing GOOGLE_PLAY_JSON_KEY_BASE64"
              exit 1
            fi

            echo "GOOGLE_PLAY_EMAIL=${{ secrets.GOOGLE_PLAY_EMAIL }}" >> $GITHUB_ENV
            echo "GOOGLE_PLAY_PASSWORD=${{ secrets.GOOGLE_PLAY_PASSWORD }}" >> $GITHUB_ENV
            echo "GOOGLE_PLAY_JSON_KEY_BASE64=${{ secrets.GOOGLE_PLAY_JSON_KEY_BASE64 }}" >> $GITHUB_ENV
          fi

      - name: Setup default Android keystore (fallback)
        id: keystore_setup
        run: |
          # Setup keystore di default (fallback) da credentials.json o GitHub Secrets
          # Il keystore specifico del cliente verr√† gestito nel loop per ogni cliente
          KEYSTORE_CONFIGURED=false
          
          # Prova credentials.json
          if [ -f "credentials.json" ]; then
            echo "üì¶ Tentativo con credentials.json per keystore (fallback)"
            KEYSTORE_PATH=$(node -e "const creds = require('./credentials.json'); console.log(creds.android?.keystore?.keystorePath || '')")
            KEYSTORE_PASSWORD=$(node -e "const creds = require('./credentials.json'); console.log(creds.android?.keystore?.keystorePassword || '')")
            KEY_ALIAS=$(node -e "const creds = require('./credentials.json'); console.log(creds.android?.keystore?.keyAlias || '')")
            KEY_PASSWORD=$(node -e "const creds = require('./credentials.json'); console.log(creds.android?.keystore?.keyPassword || '')")
            
            if [ -n "$KEYSTORE_PATH" ] && [ -n "$KEYSTORE_PASSWORD" ]; then
              # Crea directory keystore se necessario
              mkdir -p $(dirname "$KEYSTORE_PATH")
              echo "DEFAULT_KEYSTORE_PATH=$KEYSTORE_PATH" >> $GITHUB_ENV
              echo "DEFAULT_KEYSTORE_PASSWORD=$KEYSTORE_PASSWORD" >> $GITHUB_ENV
              echo "DEFAULT_KEY_ALIAS=$KEY_ALIAS" >> $GITHUB_ENV
              echo "DEFAULT_KEY_PASSWORD=$KEY_PASSWORD" >> $GITHUB_ENV
              KEYSTORE_CONFIGURED=true
              echo "‚úÖ Keystore fallback configurato da credentials.json"
            fi
          fi
          
          # Se ancora non configurato, prova GitHub Secrets
          if [ "$KEYSTORE_CONFIGURED" != "true" ]; then
            echo "üì¶ Tentativo con GitHub Secrets (fallback)..."
            mkdir -p fastlane/keystores
            if [ -n "${{ secrets.ANDROID_KEYSTORE_BASE64 }}" ]; then
              echo "${{ secrets.ANDROID_KEYSTORE_BASE64 }}" | base64 -d > fastlane/keystores/release.keystore
              KEYSTORE_ABS_PATH=$(pwd)/fastlane/keystores/release.keystore
              echo "DEFAULT_KEYSTORE_PATH=$KEYSTORE_ABS_PATH" >> $GITHUB_ENV
              echo "DEFAULT_KEYSTORE_PASSWORD=${{ secrets.ANDROID_KEYSTORE_PASSWORD }}" >> $GITHUB_ENV
              echo "DEFAULT_KEY_ALIAS=${{ secrets.ANDROID_KEY_ALIAS }}" >> $GITHUB_ENV
              echo "DEFAULT_KEY_PASSWORD=${{ secrets.ANDROID_KEY_PASSWORD }}" >> $GITHUB_ENV
              KEYSTORE_CONFIGURED=true
              echo "‚úÖ Keystore fallback configurato da GitHub Secrets"
            fi
          fi
          
          echo "keystore_configured=$KEYSTORE_CONFIGURED" >> $GITHUB_OUTPUT

      - name: Install Fastlane
        run: |
          sudo apt-get update
          sudo apt-get install -y ruby-full
          echo 'export GEM_HOME=$HOME/.gem' >> $GITHUB_ENV
          echo 'export PATH=$HOME/.gem/bin:$PATH' >> $GITHUB_ENV
          gem install --user-install fastlane -NV

      - name: Build for each client
        env:
          CLIENT_NAME: ${{ steps.client.outputs.client_name }}
          BUILD_ONLY: ${{ github.event.inputs.build_only || github.event.client_payload.build_only || 'false' }}
          DEPLOY_VPS: ${{ github.event.inputs.deploy_vps || github.event.client_payload.deploy_vps || 'true' }}
          SETUP_NGINX: ${{ github.event.inputs.setup_nginx || github.event.client_payload.setup_nginx || 'false' }}
        run: |
          # Debug: verifica branch e file clients.config.json
          echo "üîç Debug informazioni:"
          echo "   Branch corrente: $(git branch --show-current 2>/dev/null || git rev-parse --abbrev-ref HEAD)"
          echo "   Commit: $(git rev-parse HEAD)"
          echo "   File clients.config.json esiste: $([ -f clients.config.json ] && echo 'SI' || echo 'NO')"
          if [ -f clients.config.json ]; then
            echo "   Clienti nel file: $(node -e "const fs = require('fs'); const config = JSON.parse(fs.readFileSync('./clients.config.json', 'utf8')); console.log(Object.keys(config.clients || {}).join(', '))" 2>/dev/null || echo 'ERRORE LETTURA')"
          fi
          echo ""
          
          IFS=',' read -ra CLIENTS_ARRAY <<< "${{ steps.clients.outputs.clients }}"
          for CLIENT in "${CLIENTS_ARRAY[@]}"; do
            echo "üöÄ Building Android per: $CLIENT"
            
            # Determina releaseAccount per questo cliente e crea il file JSON key corretto
            CLIENT_RELEASE_ACCOUNT=$(node -e "const fs = require('fs'); const config = JSON.parse(fs.readFileSync('./clients.config.json', 'utf8')); console.log(config.clients?.['$CLIENT']?.releaseAccount || 'lorenzo')")
            echo "üîë Release account per $CLIENT: $CLIENT_RELEASE_ACCOUNT"
            
            # Crea il file google_play_json_key.json con le credenziali corrette per questo cliente
            if [ "$CLIENT_RELEASE_ACCOUNT" = "sibook" ]; then
              echo "üîµ Usando credenziali SiBook per $CLIENT"
              echo "${{ secrets.GOOGLE_PLAY_JSON_KEY_BASE64_SIBOOK }}" | base64 --decode > google_play_json_key.json
            else
              echo "üü¢ Usando credenziali Lorenzo (default) per $CLIENT"
              echo "${{ secrets.GOOGLE_PLAY_JSON_KEY_BASE64 }}" | base64 --decode > google_play_json_key.json
            fi
            
            # Verifica che il file sia stato creato correttamente
            if [ ! -f "google_play_json_key.json" ]; then
              echo "‚ùå Errore: google_play_json_key.json non creato per $CLIENT"
              exit 1
            fi
            echo "‚úÖ File google_play_json_key.json creato per $CLIENT con account $CLIENT_RELEASE_ACCOUNT"
            
            # Setup keystore specifico per questo cliente
            KEYSTORE_CONFIGURED=false
            echo "üîç Controllo configurazione keystore per cliente: $CLIENT"
            
            # Controlla se il cliente ha un keystore specifico configurato in clients.config.json
            CLIENT_KEYSTORE_PATH=$(node -e "const fs = require('fs'); const config = JSON.parse(fs.readFileSync('./clients.config.json', 'utf8')); console.log(config.clients?.['$CLIENT']?.android?.keystore?.path || '')")
            CLIENT_KEYSTORE_ALIAS=$(node -e "const fs = require('fs'); const config = JSON.parse(fs.readFileSync('./clients.config.json', 'utf8')); console.log(config.clients?.['$CLIENT']?.android?.keystore?.alias || '')")
            CLIENT_KEYSTORE_PASSWORD=$(node -e "const fs = require('fs'); const config = JSON.parse(fs.readFileSync('./clients.config.json', 'utf8')); console.log(config.clients?.['$CLIENT']?.android?.keystore?.password || '')")
            CLIENT_KEYSTORE_KEY_PASSWORD=$(node -e "const fs = require('fs'); const config = JSON.parse(fs.readFileSync('./clients.config.json', 'utf8')); console.log(config.clients?.['$CLIENT']?.android?.keystore?.keyPassword || '')")
            
            if [ -n "$CLIENT_KEYSTORE_PATH" ] && [ -n "$CLIENT_KEYSTORE_PASSWORD" ] && [ -n "$CLIENT_KEYSTORE_ALIAS" ]; then
              echo "üì¶ Keystore trovato nella configurazione del cliente"
              echo "   Path: $CLIENT_KEYSTORE_PATH"
              echo "   Alias: $CLIENT_KEYSTORE_ALIAS"
              
              # Se il path √® relativo, risolvilo rispetto alla root del progetto
              if [[ ! "$CLIENT_KEYSTORE_PATH" = /* ]]; then
                CLIENT_KEYSTORE_PATH="$(pwd)/$CLIENT_KEYSTORE_PATH"
              fi
              
              # Verifica che il file esista
              if [ -f "$CLIENT_KEYSTORE_PATH" ]; then
                export KEYSTORE_PATH="$CLIENT_KEYSTORE_PATH"
                export KEYSTORE_PASSWORD="$CLIENT_KEYSTORE_PASSWORD"
                export KEY_ALIAS="$CLIENT_KEYSTORE_ALIAS"
                if [ -n "$CLIENT_KEYSTORE_KEY_PASSWORD" ]; then
                  export KEY_PASSWORD="$CLIENT_KEYSTORE_KEY_PASSWORD"
                else
                  # Se keyPassword non √® specificato, usa la stessa password del keystore
                  export KEY_PASSWORD="$CLIENT_KEYSTORE_PASSWORD"
                fi
                KEYSTORE_CONFIGURED=true
                echo "‚úÖ Keystore configurato dalla configurazione del cliente: $CLIENT_KEYSTORE_PATH"
              else
                echo "‚ö†Ô∏è  Keystore configurato ma file non trovato: $CLIENT_KEYSTORE_PATH"
                echo "‚ö†Ô∏è  User√≤ keystore fallback se disponibile"
              fi
            fi
            
            # Se non configurato dal cliente, usa il fallback
            if [ "$KEYSTORE_CONFIGURED" != "true" ]; then
              if [ -n "${DEFAULT_KEYSTORE_PATH}" ]; then
                export KEYSTORE_PATH="${DEFAULT_KEYSTORE_PATH}"
                export KEYSTORE_PASSWORD="${DEFAULT_KEYSTORE_PASSWORD}"
                export KEY_ALIAS="${DEFAULT_KEY_ALIAS}"
                export KEY_PASSWORD="${DEFAULT_KEY_PASSWORD}"
                KEYSTORE_CONFIGURED=true
                echo "‚úÖ Usando keystore fallback: ${DEFAULT_KEYSTORE_PATH}"
              fi
            fi
            
            # Crea .env.android per questo cliente
            if [ -n "${KEYSTORE_PATH}" ]; then
              cat > .env.android << EOF
          KEYSTORE_PATH=${KEYSTORE_PATH}
          KEYSTORE_PASSWORD=${KEYSTORE_PASSWORD}
          KEY_ALIAS=${KEY_ALIAS}
          KEY_PASSWORD=${KEY_PASSWORD}
          GOOGLE_PLAY_SERVICE_ACCOUNT_JSON=./fastlane/google-play-service-account.json
          EOF
              echo "‚úÖ .env.android creato con keystore per $CLIENT"
            else
              BUILD_ONLY_VALUE="${{ github.event.inputs.build_only || github.event.client_payload.build_only || 'false' }}"
              if [ "$BUILD_ONLY_VALUE" == "true" ]; then
                cat > .env.android << EOF
          GOOGLE_PLAY_SERVICE_ACCOUNT_JSON=./fastlane/google-play-service-account.json
          EOF
                echo "‚ö†Ô∏è  .env.android creato senza keystore (build non firmato) per $CLIENT"
              else
                echo "‚ùå Nessuna configurazione keystore trovata per $CLIENT e build_only=false!"
                echo "‚ùå Configura android.keystore in clients.config.json per questo cliente"
                exit 1
              fi
            fi
            
            # Configura per il cliente (necessario per estrarre la versione)
            node scripts/build-client.js $CLIENT --production
            
            # Estrai versione da android/app/build.gradle dopo la configurazione
            APP_VERSION=$(grep -E "versionName\s+" android/app/build.gradle | sed -E 's/.*versionName\s+"([^"]+)".*/\1/' || echo "1.0.0")
            ANDROID_PACKAGE=$(grep -E "applicationId\s+" android/app/build.gradle | sed -E 's/.*applicationId\s+"([^"]+)".*/\1/' || echo "")
            APP_NAME=$(node -e "const fs = require('fs'); const config = JSON.parse(fs.readFileSync('./clients.config.json', 'utf8')); console.log(config.clients['$CLIENT']?.appName || '')")
            
            echo "APP_VERSION=$APP_VERSION" >> $GITHUB_ENV
            echo "ANDROID_PACKAGE=$ANDROID_PACKAGE" >> $GITHUB_ENV
            echo "APP_NAME=$APP_NAME" >> $GITHUB_ENV
            echo "üì¶ Versione app: $APP_VERSION"
            echo "üì± Package: $ANDROID_PACKAGE"
            
            # Setup Nginx se richiesto (prima del deploy)
            if [ "$SETUP_NGINX" == "true" ]; then
              echo "üîß Configurazione Nginx per: $CLIENT"
              
              # Genera la configurazione Nginx e lo script bash
              node scripts/setup-nginx-client.js $CLIENT
              
              # Estrai info VPS da clients.config.json e salva per lo step SSH
              VPS_PATH=$(node -e "const c=require('./clients.config.json');console.log(c.clients?.['$CLIENT']?.vpsPath||'/var/www/app-$CLIENT')")
              echo "VPS_PATH_${CLIENT}=$VPS_PATH" >> $GITHUB_ENV
              
              echo "üìã Info VPS:"
              echo "   Path: $VPS_PATH"
              
              # Verifica che i file siano stati generati
              NGINX_CONFIG_FILE="nginx-configs/${CLIENT}.conf"
              NGINX_SCRIPT_FILE="nginx-configs/setup-${CLIENT}.sh"
              
              if [ -f "$NGINX_CONFIG_FILE" ] && [ -f "$NGINX_SCRIPT_FILE" ]; then
                echo "‚úÖ Configurazione Nginx generata"
                echo "   Config: $NGINX_CONFIG_FILE"
                echo "   Script: $NGINX_SCRIPT_FILE"
                echo "üìã I file sono pronti per essere applicati sulla VPS"
              else
                echo "‚ùå File configurazione Nginx non trovati"
              fi
            fi
            
            # Gestione build e upload in base alla versione
            if [ "$BUILD_ONLY" == "true" ]; then
              # Solo build, senza upload
              fastlane android build client:$CLIENT
            elif [ "$APP_VERSION" == "1.0.0" ]; then
              # Prima release: solo build, l'upload sar√† gestito dal repository di automazione
              echo "üÜï Prima release (1.0.0) - build completato, upload gestito da repository di automazione"
              fastlane android build client:$CLIENT
              
              # Trova il percorso del file .aab (usa percorso assoluto per evitare problemi con cd)
              AAB_PATH="build/android/${CLIENT}/app-release.aab"
              if [ ! -f "$AAB_PATH" ]; then
                echo "‚ö†Ô∏è  File .aab non trovato in $AAB_PATH, cerco in altri percorsi..."
                # Prova percorso alternativo
                AAB_PATH=$(find build/android -name "app-release.aab" | head -1)
                if [ -z "$AAB_PATH" ]; then
                  echo "‚ùå File .aab non trovato!"
                  echo "üîç Directory corrente: $(pwd)"
                  echo "üîç Contenuto directory build:"
                  ls -la build/ || echo "Directory build non esiste"
                  echo "üîç Contenuto directory build/android:"
                  ls -la build/android/ || echo "Directory build/android non esiste"
                  exit 1
                fi
              fi
              
              # Converti in percorso assoluto per evitare problemi quando cambiamo directory
              # Usa readlink -f per ottenere il percorso assoluto canonico
              if command -v readlink >/dev/null 2>&1; then
                AAB_PATH_ABS=$(readlink -f "$AAB_PATH")
              else
                # Fallback per macOS (readlink -f non disponibile)
                AAB_PATH_ABS=$(cd "$(dirname "$AAB_PATH")" && pwd)/$(basename "$AAB_PATH")
              fi
              
              echo "üì¶ File .aab trovato: $AAB_PATH"
              echo "üì¶ Percorso assoluto: $AAB_PATH_ABS"
              echo "üîç Directory corrente: $(pwd)"
              
              # Verifica che il file esista nel percorso assoluto
              if [ ! -f "$AAB_PATH_ABS" ]; then
                echo "‚ùå ERRORE: File .aab non trovato nel percorso assoluto: $AAB_PATH_ABS"
                echo "üîç Directory corrente: $(pwd)"
                echo "üîç Contenuto directory build/android:"
                ls -la build/android/ || echo "Directory build/android non esiste"
                if [ -d "build/android/${CLIENT}" ]; then
                  echo "üîç Contenuto directory build/android/${CLIENT}:"
                  ls -la "build/android/${CLIENT}/"
                fi
                exit 1
              fi
              echo "‚úÖ File .aab verificato nel percorso assoluto: $AAB_PATH_ABS"
              echo "üìä Dimensione file: $(ls -lh "$AAB_PATH_ABS" | awk '{print $5}')"
              
              # Chiama il repository di automazione per creare l'app
              echo "üÜï Chiamando repository di automazione per creare app su Play Store"
              
              # Determina il percorso dell'icona in base al cliente
              # Per sibook-app-ionic: clients/<client>/logos/logo-lg.png
              # Per sibook-app-refactor: assets/images/logo-lg.png (default)
              ICON_PATH=""
              if [ -f "clients/${CLIENT}/logos/logo-lg.png" ]; then
                # sibook-app-ionic: usa il logo del cliente specifico
                # Il percorso √® relativo alla directory del repository di automazione (che sar√† clonato dopo)
                ICON_PATH="../clients/${CLIENT}/logos/logo-lg.png"
                echo "üì∑ Usando logo cliente: $ICON_PATH"
              elif [ -f "assets/images/logo-lg.png" ]; then
                # sibook-app-refactor: usa il logo standard
                ICON_PATH="../assets/images/logo-lg.png"
                echo "üì∑ Usando logo standard: $ICON_PATH"
              else
                echo "‚ö†Ô∏è  Logo non trovato, verr√† usato il default del repository di automazione"
              fi
              
              # Determina il percorso degli screenshots in base al progetto
              # Per sibook-app-ionic: fastlane/metadata/android/it-IT/images/phoneScreenshots (se esiste) o fastlane/metadata/screenshots/it/
              # Per sibook-app-refactor: fastlane/metadata/android/it-IT/images/phoneScreenshots (default)
              SCREENSHOTS_PATH=""
              if [ -d "fastlane/metadata/android/it-IT/images/phoneScreenshots" ]; then
                # sibook-app-ionic o sibook-app-refactor: usa la directory Android standard
                SCREENSHOTS_PATH="../fastlane/metadata/android/it-IT/images/phoneScreenshots"
                echo "üì∏ Usando screenshots Android: $SCREENSHOTS_PATH"
              elif [ -d "fastlane/metadata/screenshots/it" ]; then
                # sibook-app-ionic: usa la directory screenshots/it/ (potrebbe contenere screenshot iOS, ma proviamo)
                SCREENSHOTS_PATH="../fastlane/metadata/screenshots/it"
                echo "üì∏ Usando screenshots da screenshots/it: $SCREENSHOTS_PATH"
                echo "‚ö†Ô∏è  Nota: questa directory potrebbe contenere screenshot iOS, verifica che siano compatibili"
              else
                echo "‚ö†Ô∏è  Directory screenshots non trovata, verr√† usato il default del repository di automazione"
              fi
              
              # Checkout Easybook Automation Repository usando git clone con token
              git clone https://${{ secrets.EASYBOOK_RELEASE_AUTOMATION_REPO_TOKEN }}@github.com/lorenzomalla/easybook-release-automation-android.git easybook-release-automation-android || true
              cd easybook-release-automation-android
              npm ci
              
              # Se SIBOOK_RELEASE = true, usa lo script dedicato
              if [ "$SIBOOK_RELEASE" == "true" ]; then
                export GOOGLE_PLAY_EMAIL="${{ env.GOOGLE_PLAY_EMAIL }}"
                export GOOGLE_PLAY_PASSWORD="${{ env.GOOGLE_PLAY_PASSWORD }}"
                export APP_NAME="$APP_NAME"
                export APP_BUNDLE_IDENTIFIER="$ANDROID_PACKAGE"
                export APP_VERSION="$APP_VERSION"
                if [ -n "$ICON_PATH" ]; then
                  export ICON_DIR="$ICON_PATH"
                  echo "üì∑ ICON_DIR impostato a: $ICON_PATH"
                fi
                if [ -n "$SCREENSHOTS_PATH" ]; then
                  export SCREENSHOTS_DIR="$SCREENSHOTS_PATH"
                  echo "üì∏ SCREENSHOTS_DIR impostato a: $SCREENSHOTS_PATH"
                fi
                if [ -n "$AAB_PATH_ABS" ]; then
                  export AAB_PATH="$AAB_PATH_ABS"
                  echo "üì¶ AAB_PATH impostato a: $AAB_PATH (percorso assoluto)"
                  echo "üîç Verifica file prima di passarlo:"
                  if [ -f "$AAB_PATH" ]; then
                    echo "‚úÖ File esiste: $AAB_PATH"
                    ls -lh "$AAB_PATH"
                  else
                    echo "‚ùå File NON esiste: $AAB_PATH"
                    echo "üîç Directory corrente: $(pwd)"
                    echo "üîç Contenuto directory parent:"
                    ls -la ../ || echo "Directory parent non accessibile"
                  fi
                elif [ -n "$AAB_PATH" ]; then
                  # Fallback: usa percorso relativo
                  export AAB_PATH="../$AAB_PATH"
                  echo "üì¶ AAB_PATH impostato a: $AAB_PATH (percorso relativo)"
                fi
                npm run release:sibook
              else
                export GOOGLE_PLAY_EMAIL="${{ env.GOOGLE_PLAY_EMAIL }}"
                export GOOGLE_PLAY_PASSWORD="${{ env.GOOGLE_PLAY_PASSWORD }}"
                export APP_NAME="$APP_NAME"
                export APP_BUNDLE_IDENTIFIER="$ANDROID_PACKAGE"
                export APP_VERSION="$APP_VERSION"
                if [ -n "$ICON_PATH" ]; then
                  export ICON_DIR="$ICON_PATH"
                  echo "üì∑ ICON_DIR impostato a: $ICON_PATH"
                fi
                if [ -n "$SCREENSHOTS_PATH" ]; then
                  export SCREENSHOTS_DIR="$SCREENSHOTS_PATH"
                  echo "üì∏ SCREENSHOTS_DIR impostato a: $SCREENSHOTS_PATH"
                fi
                if [ -n "$AAB_PATH_ABS" ]; then
                  export AAB_PATH="$AAB_PATH_ABS"
                  echo "üì¶ AAB_PATH impostato a: $AAB_PATH (percorso assoluto)"
                  echo "üîç Verifica file prima di passarlo:"
                  if [ -f "$AAB_PATH" ]; then
                    echo "‚úÖ File esiste: $AAB_PATH"
                    ls -lh "$AAB_PATH"
                  else
                    echo "‚ùå File NON esiste: $AAB_PATH"
                    echo "üîç Directory corrente: $(pwd)"
                    echo "üîç Contenuto directory parent:"
                    ls -la ../ || echo "Directory parent non accessibile"
                  fi
                elif [ -n "$AAB_PATH" ]; then
                  # Fallback: usa percorso relativo
                  export AAB_PATH="../$AAB_PATH"
                  echo "üì¶ AAB_PATH impostato a: $AAB_PATH (percorso relativo)"
                fi
                npm run start
              fi
              
              cd ..
            else
              # Aggiornamenti: usa Fastlane con JSON key per upload
              echo "üîÑ Aggiornamento ($APP_VERSION) - upload tramite Fastlane"
              # Passa le variabili d'ambiente necessarie per l'upload (come in build.yml)
              export ANDROID_PACKAGE_NAME="$ANDROID_PACKAGE"
              export GOOGLE_PLAY_JSON_KEY="google_play_json_key.json"
              fastlane android release client:$CLIENT deploy_vps:$DEPLOY_VPS
            fi
            
            echo "‚úÖ Build completata per: $CLIENT"
          done

      - name: Copy Nginx configuration to VPS
        if: ${{ github.event.inputs.setup_nginx == 'true' || github.event.client_payload.setup_nginx == 'true' }}
        uses: appleboy/scp-action@master
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SECRET_KEY }}
          source: "nginx-configs/*"
          target: "/tmp/"

      - name: Apply Nginx configuration on VPS
        if: ${{ github.event.inputs.setup_nginx == 'true' || github.event.client_payload.setup_nginx == 'true' }}
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SECRET_KEY }}
          script: |
            # Estrai info dal client
            CLIENT="${{ steps.client.outputs.client_name }}"
            
            # Usa il path VPS passato come variabile o default
            VPS_PATH="${VPS_PATH:-/var/www/app-${CLIENT}}"
            
            echo "üîß Applicazione configurazione Nginx per: $CLIENT"
            echo "   Path: $VPS_PATH"
            
            # Crea directory
            mkdir -p $VPS_PATH
            chown -R www-data:www-data $VPS_PATH
            chmod -R 755 $VPS_PATH
            
            # Applica configurazione Nginx se presente
            if [ -f "/tmp/${CLIENT}.conf" ]; then
              # Copia configurazione Nginx
              sudo cp /tmp/${CLIENT}.conf /etc/nginx/sites-available/${CLIENT}
              
              # Abilita il sito
              sudo ln -sf /etc/nginx/sites-available/${CLIENT} /etc/nginx/sites-enabled/
              sudo rm -f /etc/nginx/sites-enabled/default
              
              # Testa e riavvia Nginx
              if sudo nginx -t; then
                sudo systemctl restart nginx
                echo "‚úÖ Configurazione Nginx applicata e Nginx riavviato"
              else
                echo "‚ùå Errore nella configurazione Nginx!"
                exit 1
              fi
            else
              echo "‚ö†Ô∏è  File configurazione Nginx non trovato: /tmp/${CLIENT}.conf"
              echo "üìã Applica manualmente usando lo script bash generato"
            fi

      - name: Upload build artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: android-builds
          path: |
            build/android/**
          retention-days: 30

      - name: Summary
        if: always()
        run: |
          echo "## ‚úÖ Build Android Completata" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Client buildati:** ${{ steps.clients.outputs.clients }}" >> $GITHUB_STEP_SUMMARY
          echo "**Build only:** ${{ github.event.inputs.build_only || github.event.client_payload.build_only || 'false' }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Gli artifact sono disponibili nella sezione Artifacts di questo workflow." >> $GITHUB_STEP_SUMMARY

