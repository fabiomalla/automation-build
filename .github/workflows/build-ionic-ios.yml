run-name: Build Ionic iOS - ${{ github.event.inputs.client_name || 'all' }}

on:
  workflow_dispatch:
    inputs:
      client_name:
        description: "Nome del cliente da buildare (es: napoli, sibook-tattoo)"
        required: true
        type: string
      branch:
        description: "Branch del repository privato da buildare"
        required: false
        default: "main"
        type: string
      build_only:
        description: "Solo build senza upload (default: false)"
        required: false
        default: false
        type: boolean
      deploy_vps:
        description: "Deploy su VPS dopo build (default: true)"
        required: false
        default: true
        type: boolean
      setup_nginx:
        description: "Configura Nginx sulla VPS (crea config, URL, etc.) (default: false)"
        required: false
        default: false
        type: boolean
  repository_dispatch:
    types: [build-ionic-ios]

env:
  NODE_VERSION: '22.21.1'
  XCODE_VERSION: '15.4'

jobs:
  build_ios:
    runs-on: macos-14

    steps:
      - name: Checkout the Private Repository
        uses: actions/checkout@v3
        with:
          repository: lorenzomalla/sibook-app-ionic
          token: ${{ secrets.EASYBOOK_RELEASE_AUTOMATION_REPO_TOKEN }}
          ref: ${{ github.event.inputs.branch || github.event.client_payload.branch || 'main' }}

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Setup Xcode
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: ${{ env.XCODE_VERSION }}

      - name: Install dependencies
        run: |
          # Rimuovi package-lock.json e node_modules per evitare bug npm con dipendenze opzionali
          rm -rf node_modules package-lock.json
          npm install

      # Flag: se esiste sibook.txt => build per account SiBook
      - name: Detect SiBook release flag
        run: |
          if [ -f "sibook.txt" ]; then
            echo "SIBOOK_RELEASE=true" >> $GITHUB_ENV
          else
            echo "SIBOOK_RELEASE=false" >> $GITHUB_ENV
          fi

      - name: Set environment variables for iOS and handle APPLE_P8
        run: |
          echo "Setting environment variables for iOS"

          if [ "$SIBOOK_RELEASE" = "true" ]; then
            echo "ðŸ”µ Using SiBook Apple account"
            echo "APPLE_ID=${{ secrets.APPLE_ID_SIBOOK }}" >> $GITHUB_ENV
            echo "APPLE_ISSUER_ID=${{ secrets.APPLE_ISSUER_ID_SIBOOK }}" >> $GITHUB_ENV
            echo "APPLE_KEY_ID=${{ secrets.APPLE_KEY_ID_SIBOOK }}" >> $GITHUB_ENV
            echo "APPLE_TEAM_ID=${{ secrets.APPLE_TEAM_ID_SIBOOK }}" >> $GITHUB_ENV
            echo "CERT_P12_BASE64=${{ secrets.CERT_P12_BASE64_SIBOOK }}" >> $GITHUB_ENV
            echo "CERT_P12_PASSWORD=${{ secrets.CERT_P12_PASSWORD_SIBOOK }}" >> $GITHUB_ENV
            echo "APPLE_P8=${{ secrets.APPLE_P8_SIBOOK }}" >> $GITHUB_ENV
          else
            echo "ðŸŸ¢ Using Lorenzo Apple account"
            echo "APPLE_ID=${{ secrets.APPLE_ID }}" >> $GITHUB_ENV
            echo "APPLE_ISSUER_ID=${{ secrets.APPLE_ISSUER_ID }}" >> $GITHUB_ENV
            echo "APPLE_KEY_ID=${{ secrets.APPLE_KEY_ID }}" >> $GITHUB_ENV
            echo "APPLE_TEAM_ID=${{ secrets.APPLE_TEAM_ID }}" >> $GITHUB_ENV
            echo "CERT_P12_BASE64=${{ secrets.CERT_P12_BASE64 }}" >> $GITHUB_ENV
            echo "CERT_P12_PASSWORD=${{ secrets.CERT_P12_PASSWORD }}" >> $GITHUB_ENV
            echo "APPLE_P8=${{ secrets.APPLE_P8 }}" >> $GITHUB_ENV
          fi

      - name: Determine client name
        id: client
        run: |
          if [ -n "${{ github.event.inputs.client_name }}" ]; then
            CLIENT_NAME="${{ github.event.inputs.client_name }}"
          elif [ -n "${{ github.event.client_payload.client_name }}" ]; then
            CLIENT_NAME="${{ github.event.client_payload.client_name }}"
          else
            CLIENT_NAME="all"
          fi
          echo "client_name=$CLIENT_NAME" >> $GITHUB_OUTPUT
          echo "ðŸ” Client da buildare: $CLIENT_NAME"

      - name: Get clients list
        id: clients
        run: |
          if [ "${{ steps.client.outputs.client_name }}" == "all" ]; then
            CLIENTS=$(node -e "const fs = require('fs'); const config = JSON.parse(fs.readFileSync('./clients.config.json', 'utf8')); console.log(Object.keys(config.clients).join(','))")
            echo "clients=$CLIENTS" >> $GITHUB_OUTPUT
            echo "ðŸ“¦ Clienti trovati: $CLIENTS"
          else
            echo "clients=${{ steps.client.outputs.client_name }}" >> $GITHUB_OUTPUT
          fi

      - name: Create Keychain
        run: |
          security create-keychain -p "${{ secrets.KEYCHAIN_PASSWORD }}" build.keychain
          security default-keychain -s build.keychain
          security unlock-keychain -p "${{ secrets.KEYCHAIN_PASSWORD }}" build.keychain
          security set-keychain-settings -t 3600 -u build.keychain

      - name: Decode and Create Certificate and Provisioning Profile
        run: |
          echo "${{ env.CERT_P12_BASE64 }}" | base64 --decode > certificate.p12
          security import certificate.p12 -P "${{ env.CERT_P12_PASSWORD }}" -A -T /usr/bin/codesign -T /usr/bin/security
          security set-key-partition-list -S apple-tool:,apple: -s -k "${{ secrets.KEYCHAIN_PASSWORD }}" build.keychain
          
          # Decodifica provisioning profiles se disponibili (opzionale, possono essere scaricati da sigh)
          if [ -n "${{ secrets.PROVISIONING_PROFILE_BASE64 }}" ]; then
            echo "${{ secrets.PROVISIONING_PROFILE_BASE64 }}" | base64 --decode > provisioning_profile.mobileprovision
            echo "âœ… Provisioning profile decodificato"
          else
            echo "â„¹ï¸  PROVISIONING_PROFILE_BASE64 non trovato, verranno scaricati da sigh se necessario"
          fi
          
          if [ -n "${{ secrets.PROVISIONING_PROFILE_ONESIGNAL_BASE64 }}" ]; then
            echo "${{ secrets.PROVISIONING_PROFILE_ONESIGNAL_BASE64 }}" | base64 --decode > provisioning_profile_onesignal.mobileprovision
            echo "âœ… Provisioning profile OneSignal decodificato"
          fi

      - name: Configure Fastlane API Key
        run: |
          mkdir -p fastlane
          echo "${{ env.APPLE_P8 }}" | base64 --decode > fastlane/AuthKey.p8
          jq -n \
            --arg key_id "${{ env.APPLE_KEY_ID }}" \
            --arg issuer_id "${{ env.APPLE_ISSUER_ID }}" \
            --arg key "$(cat fastlane/AuthKey.p8)" \
            --argjson in_house false \
            '{key_id: $key_id, issuer_id: $issuer_id, key: $key, in_house: $in_house}' > fastlane/api_key.json

      - name: Create .env.ios
        run: |
          cat > .env.ios << EOF
          APP_STORE_CONNECT_API_KEY_ID=${{ env.APPLE_KEY_ID }}
          APP_STORE_CONNECT_ISSUER_ID=${{ env.APPLE_ISSUER_ID }}
          APP_STORE_CONNECT_API_KEY_PATH=./fastlane/AuthKey.p8
          FASTLANE_USER=${{ env.APPLE_ID }}
          FASTLANE_APPLE_APPLICATION_SPECIFIC_PASSWORD=${{ secrets.FASTLANE_APPLE_APPLICATION_SPECIFIC_PASSWORD }}
          FASTLANE_ITC_TEAM_ID=${{ env.APPLE_TEAM_ID }}
          FASTLANE_TEAM_ID=${{ env.APPLE_TEAM_ID }}
          EOF

      - name: Install Fastlane on macOS (user install)
        run: |
          echo 'export GEM_HOME=$HOME/.gem' >> $GITHUB_ENV
          echo 'export PATH=$HOME/.gem/bin:$PATH' >> $GITHUB_ENV
          gem install --user-install fastlane -NV

      - name: Install jq
        run: |
          if ! command -v jq &> /dev/null; then
            brew install jq
          else
            echo "jq is already installed"
          fi

      - name: Build for each client
        env:
          CLIENT_NAME: ${{ steps.client.outputs.client_name }}
          BUILD_ONLY: ${{ github.event.inputs.build_only || github.event.client_payload.build_only || 'false' }}
          DEPLOY_VPS: ${{ github.event.inputs.deploy_vps || github.event.client_payload.deploy_vps || 'true' }}
          SETUP_NGINX: ${{ github.event.inputs.setup_nginx || github.event.client_payload.setup_nginx || 'false' }}
          APPLE_TEAM_ID: ${{ env.APPLE_TEAM_ID }}
          APPLE_KEY_ID: ${{ env.APPLE_KEY_ID }}
          APPLE_ISSUER_ID: ${{ env.APPLE_ISSUER_ID }}
        run: |
          IFS=',' read -ra CLIENTS_ARRAY <<< "${{ steps.clients.outputs.clients }}"
          for CLIENT in "${CLIENTS_ARRAY[@]}"; do
            echo "ðŸš€ Building iOS per: $CLIENT"
            
            # Configura per il cliente (necessario per estrarre info)
            node scripts/build-client.js $CLIENT --production
            
            # Estrai info dal progetto iOS dopo la configurazione
            # Per iOS, la versione Ã¨ in ios/App/App.xcodeproj/project.pbxproj o Info.plist
            # Per semplicitÃ , usiamo la versione da package.json o assumiamo 1.0.0 se non trovata
            APP_VERSION=$(grep -E '"version"' package.json | head -1 | sed -E 's/.*"version":\s*"([^"]+)".*/\1/' || echo "1.0.0")
            BUNDLE_ID=$(node -e "const fs = require('fs'); const config = JSON.parse(fs.readFileSync('./clients.config.json', 'utf8')); console.log(config.clients['$CLIENT']?.appId || '')")
            APP_NAME=$(node -e "const fs = require('fs'); const config = JSON.parse(fs.readFileSync('./clients.config.json', 'utf8')); console.log(config.clients['$CLIENT']?.appName || '')")
            
            echo "APP_VERSION=$APP_VERSION" >> $GITHUB_ENV
            echo "BUNDLE_ID=$BUNDLE_ID" >> $GITHUB_ENV
            echo "APP_NAME=$APP_NAME" >> $GITHUB_ENV
            echo "ðŸ“¦ Versione app: $APP_VERSION"
            echo "ðŸ“± Bundle ID: $BUNDLE_ID"
            
            # Setup Nginx se richiesto (prima del deploy)
            if [ "$SETUP_NGINX" == "true" ]; then
              echo "ðŸ”§ Configurazione Nginx per: $CLIENT"
              
              # Genera la configurazione Nginx e lo script bash
              node scripts/setup-nginx-client.js $CLIENT
              
              # Estrai info VPS da clients.config.json
              VPS_PATH=$(node -e "const c=require('./clients.config.json');console.log(c.clients?.['$CLIENT']?.vpsPath||'/var/www/app-$CLIENT')")
              echo "VPS_PATH_${CLIENT}=$VPS_PATH" >> $GITHUB_ENV
              
              echo "ðŸ“‹ Info VPS:"
              echo "   Path: $VPS_PATH"
              
              # Verifica che i file siano stati generati
              NGINX_CONFIG_FILE="nginx-configs/${CLIENT}.conf"
              NGINX_SCRIPT_FILE="nginx-configs/setup-${CLIENT}.sh"
              
              if [ -f "$NGINX_CONFIG_FILE" ] && [ -f "$NGINX_SCRIPT_FILE" ]; then
                echo "âœ… Configurazione Nginx generata"
                echo "   Config: $NGINX_CONFIG_FILE"
                echo "   Script: $NGINX_SCRIPT_FILE"
                echo "ðŸ“‹ I file sono pronti per essere applicati sulla VPS"
              else
                echo "âŒ File configurazione Nginx non trovati"
              fi
            fi
            
            # Estrai e trasforma nome app per bundle target (come in build.yml)
            NAME="$APP_NAME"
            BUNDLE_TARGET=$(echo "$NAME" | node -e "
              const name = require('fs').readFileSync(0, 'utf-8').trim();
              const normalized = name.normalize('NFKD').replace(/[\u0300-\u036f]/g, '');
              const bundleTarget = normalized.replace(/[^0-9A-Za-z]/g, '').slice(0, 60) || 'IonicApp';
              console.log(bundleTarget);
            ")
            EXTENSION_BUNDLE_ID="${BUNDLE_ID}.OneSignalNotificationServiceExtension"
            
            echo "BUNDLE_TARGET=$BUNDLE_TARGET" >> $GITHUB_ENV
            echo "EXTENSION_BUNDLE_ID=$EXTENSION_BUNDLE_ID" >> $GITHUB_ENV
            
            # Sincronizza Capacitor iOS (crea/aggiorna struttura iOS)
            # Nota: cap sync NON crea il Podfile se non esiste giÃ 
            echo "ðŸ”„ Sincronizzazione Capacitor iOS..."
            PRODUCTION_SERVER_URL=$(node -e "const fs = require('fs'); const config = JSON.parse(fs.readFileSync('./clients.config.json', 'utf8')); console.log(config.clients['$CLIENT']?.productionServerUrl || '')")
            PRODUCTION_SERVER_URL="$PRODUCTION_SERVER_URL" npx cap sync ios
            
            # Fix OneSignal Package Swift (cap sync lo cancella/rigenera)
            echo "ðŸ”§ Fix OneSignal Package Swift..."
            node scripts/fix-onesignal-package.js
            
            # Crea Podfile minimo se non esiste (necessario per creare il workspace)
            # Capacitor 8 usa SPM per le dipendenze native, ma il workspace viene creato da pod install
            if [ ! -f "ios/App/Podfile" ]; then
              echo "ðŸ“ Creazione Podfile minimo (necessario per creare workspace)..."
              echo "# DO NOT MODIFY -- Auto-generated for workspace creation" > ios/App/Podfile
              echo "# Capacitor 8 uses Swift Package Manager (SPM) for native dependencies" >> ios/App/Podfile
              echo "# This Podfile is minimal and only needed to create the workspace" >> ios/App/Podfile
              echo "platform :ios, '15.0'" >> ios/App/Podfile
              echo "" >> ios/App/Podfile
              echo "target 'App' do" >> ios/App/Podfile
              echo "  # No pods needed - Capacitor 8 uses SPM" >> ios/App/Podfile
              echo "end" >> ios/App/Podfile
              echo "âœ… Podfile minimo creato"
            else
              echo "âœ… Podfile trovato"
            fi
            
            # Installa CocoaPods dependencies per creare il workspace
            # Anche con un Podfile vuoto, pod install crea il workspace necessario
            if [ -f "ios/App/Podfile" ]; then
              echo "ðŸ“¦ Installazione CocoaPods (crea workspace)..."
              cd ios/App
              
              # Esegui pod install (anche con Podfile vuoto crea il workspace)
              if pod install --repo-update; then
                echo "âœ… pod install completato"
              else
                echo "âš ï¸  pod install ha avuto problemi, ma potrebbe aver creato il workspace"
              fi
              
              cd ../..
              
              # Verifica che il workspace sia stato creato
              if [ -d "ios/App/App.xcworkspace" ]; then
                echo "âœ… Workspace creato: ios/App/App.xcworkspace"
              else
                echo "âŒ Workspace non creato dopo pod install!"
                echo "ðŸ“‹ Lista file in ios/App/:"
                ls -la ios/App/ | head -20
                echo "ðŸ“‹ Contenuto Podfile:"
                cat ios/App/Podfile
                exit 1
              fi
            else
              echo "âŒ Podfile non trovato dopo la creazione!"
              exit 1
            fi
            
            # Run Fastlane Create App (crea app e provisioning profiles)
            # Esegui sempre create_app per assicurarsi che Push Notifications sia abilitato
            # (create_app gestisce il caso in cui l'app esista giÃ )
            if [ "$BUILD_ONLY" != "true" ]; then
              if [ "$APP_VERSION" == "1.0.0" ]; then
                echo "ðŸ†• Prima release (1.0.0) - creando app su App Store Connect"
              else
                echo "ðŸ”„ Verificando/abilitando Push Notifications sull'App ID esistente"
              fi
              export AUTH_KEY_PATH="fastlane/AuthKey.p8"
              export APPLE_ID="${{ env.APPLE_ID }}"
              export APPLE_KEY_ID="${{ env.APPLE_KEY_ID }}"
              export APPLE_ISSUER_ID="${{ env.APPLE_ISSUER_ID }}"
              export BUNDLE_ID="$BUNDLE_ID"
              export EXTENSION_BUNDLE_ID="$EXTENSION_BUNDLE_ID"
              export APP_NAME="$APP_NAME"
              fastlane create_app
              echo "âœ… App verificata/creata e Push Notifications abilitato su App Store Connect"
            fi
            
            # Crea credentials.json per iOS (come in build.yml)
            echo "{
              \"ios\": {
                \"OneSignalNotificationServiceExtension\": {
                  \"distributionCertificate\": {
                    \"path\": \"certificate.p12\",
                    \"password\": \"${{ env.CERT_P12_PASSWORD }}\"
                  },
                  \"provisioningProfilePath\": \"provisioning_profile_onesignal.mobileprovision\"
                },
                \"${BUNDLE_TARGET}\": {
                  \"distributionCertificate\": {
                    \"path\": \"certificate.p12\",
                    \"password\": \"${{ env.CERT_P12_PASSWORD }}\"
                  },
                  \"provisioningProfilePath\": \"provisioning_profile.mobileprovision\"
                }
              }
            }" > ./credentials.json
            
            # Build iOS con variabili d'ambiente
            export EXPO_APPLE_TEAM_ID="${{ env.APPLE_TEAM_ID }}"
            export EXPO_APPLE_KEY_ID="${{ env.APPLE_KEY_ID }}"
            export EXPO_APPLE_ISSUER_ID="${{ env.APPLE_ISSUER_ID }}"
            export EXPO_APPLE_API_KEY_PATH="fastlane/AuthKey.p8"
            # Passa anche le variabili standard per compatibilitÃ  con Fastfile
            export APPLE_TEAM_ID="${{ env.APPLE_TEAM_ID }}"
            export APPLE_KEY_ID="${{ env.APPLE_KEY_ID }}"
            export APPLE_ISSUER_ID="${{ env.APPLE_ISSUER_ID }}"
            export AUTH_KEY_PATH="fastlane/AuthKey.p8"
            
            if [ "$BUILD_ONLY" == "true" ]; then
              fastlane ios build client:$CLIENT
            else
              fastlane ios release client:$CLIENT deploy_vps:$DEPLOY_VPS
            fi
            
            echo "âœ… Build completata per: $CLIENT"
          done

      - name: Copy Nginx configuration to VPS
        if: ${{ github.event.inputs.setup_nginx == 'true' || github.event.client_payload.setup_nginx == 'true' }}
        uses: appleboy/scp-action@master
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SECRET_KEY }}
          source: "nginx-configs/*"
          target: "/tmp/"

      - name: Extract VPS paths for Nginx setup
        if: ${{ github.event.inputs.setup_nginx == 'true' || github.event.client_payload.setup_nginx == 'true' }}
        id: vps_paths
        run: |
          IFS=',' read -ra CLIENTS_ARRAY <<< "${{ steps.clients.outputs.clients }}"
          VPS_PATHS=""
          for CLIENT in "${CLIENTS_ARRAY[@]}"; do
            VPS_PATH=$(node -e "const c=require('./clients.config.json');console.log(c.clients?.['$CLIENT']?.vpsPath||'/var/www/app-$CLIENT')")
            VPS_PATHS="${VPS_PATHS}${CLIENT}:${VPS_PATH} "
          done
          echo "paths=${VPS_PATHS}" >> $GITHUB_OUTPUT

      - name: Apply Nginx configuration on VPS
        if: ${{ github.event.inputs.setup_nginx == 'true' || github.event.client_payload.setup_nginx == 'true' }}
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SECRET_KEY }}
          script: |
            # Estrai info dal client
            CLIENT="${{ steps.client.outputs.client_name }}"
            
            # Estrai VPS_PATH dalla lista generata
            VPS_PATHS="${{ steps.vps_paths.outputs.paths }}"
            VPS_PATH=$(echo "$VPS_PATHS" | grep -o "${CLIENT}:[^ ]*" | cut -d: -f2)
            VPS_PATH="${VPS_PATH:-/var/www/app-${CLIENT}}"
            
            echo "ðŸ”§ Applicazione configurazione Nginx per: $CLIENT"
            echo "   Path: $VPS_PATH"
            
            # Crea directory
            mkdir -p $VPS_PATH
            chown -R www-data:www-data $VPS_PATH
            chmod -R 755 $VPS_PATH
            
            # Applica configurazione Nginx se presente
            if [ -f "/tmp/${CLIENT}.conf" ]; then
              # Copia configurazione Nginx
              sudo cp /tmp/${CLIENT}.conf /etc/nginx/sites-available/${CLIENT}
              
              # Abilita il sito
              sudo ln -sf /etc/nginx/sites-available/${CLIENT} /etc/nginx/sites-enabled/
              sudo rm -f /etc/nginx/sites-enabled/default
              
              # Testa e riavvia Nginx
              if sudo nginx -t; then
                sudo systemctl restart nginx
                echo "âœ… Configurazione Nginx applicata e Nginx riavviato"
              else
                echo "âŒ Errore nella configurazione Nginx!"
                exit 1
              fi
            else
              echo "âš ï¸  File configurazione Nginx non trovato: /tmp/${CLIENT}.conf"
              echo "ðŸ“‹ Applica manualmente usando lo script bash generato"
            fi

      - name: Upload build artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ios-builds
          path: |
            build/ios/**
          retention-days: 30

      - name: Summary
        if: always()
        run: |
          echo "## âœ… Build iOS Completata" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Client buildati:** ${{ steps.clients.outputs.clients }}" >> $GITHUB_STEP_SUMMARY
          echo "**Build only:** ${{ github.event.inputs.build_only || github.event.client_payload.build_only || 'false' }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Gli artifact sono disponibili nella sezione Artifacts di questo workflow." >> $GITHUB_STEP_SUMMARY

